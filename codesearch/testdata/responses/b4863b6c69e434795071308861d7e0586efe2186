{"file_info_response":[{"return_code":1,"file_info":{"name":"src/net/url_request/url_request_job.h","lines":"459","size":"19210","language":"c++","type":1,"md5":"e374bfc3b8a8ab8596187bc6b771e892","changelist_num":"40d02904f5ee153daa2d5cd666ccfdf2756687ce","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef NET_URL_REQUEST_URL_REQUEST_JOB_H_\n#define NET_URL_REQUEST_URL_REQUEST_JOB_H_\n\n#include \u003cstdint.h\u003e\n\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\n#include \"base/macros.h\"\n#include \"base/memory/weak_ptr.h\"\n#include \"base/power_monitor/power_observer.h\"\n#include \"net/base/host_port_pair.h\"\n#include \"net/base/load_states.h\"\n#include \"net/base/net_error_details.h\"\n#include \"net/base/net_export.h\"\n#include \"net/base/request_priority.h\"\n#include \"net/cookies/canonical_cookie.h\"\n#include \"net/filter/source_stream.h\"\n#include \"net/http/http_raw_request_headers.h\"\n#include \"net/http/http_response_headers.h\"\n#include \"net/socket/connection_attempts.h\"\n#include \"net/url_request/redirect_info.h\"\n#include \"net/url_request/url_request.h\"\n#include \"url/gurl.h\"\n\nnamespace net {\n\nclass AuthChallengeInfo;\nclass AuthCredentials;\nclass CookieOptions;\nclass HttpRequestHeaders;\nclass HttpResponseInfo;\nclass IOBuffer;\nstruct LoadTimingInfo;\nclass NetworkDelegate;\nclass ProxyServer;\nclass SSLCertRequestInfo;\nclass SSLInfo;\nclass SSLPrivateKey;\nclass UploadDataStream;\nclass URLRequestStatus;\nclass X509Certificate;\n\nclass NET_EXPORT URLRequestJob : public base::PowerObserver {\n public:\n  explicit URLRequestJob(URLRequest* request,\n                         NetworkDelegate* network_delegate);\n  ~URLRequestJob() override;\n\n  // Returns the request that owns this job.\n  URLRequest* request() const {\n    return request_;\n  }\n\n  // Sets the upload data, most requests have no upload data, so this is a NOP.\n  // Job types supporting upload data will override this.\n  virtual void SetUpload(UploadDataStream* upload_data_stream);\n\n  // Sets extra request headers for Job types that support request\n  // headers. Called once before Start() is called.\n  virtual void SetExtraRequestHeaders(const HttpRequestHeaders\u0026 headers);\n\n  // Sets the priority of the job. Called once before Start() is\n  // called, but also when the priority of the parent request changes.\n  virtual void SetPriority(RequestPriority priority);\n\n  // If any error occurs while starting the Job, NotifyStartError should be\n  // called.\n  // This helps ensure that all errors follow more similar notification code\n  // paths, which should simplify testing.\n  virtual void Start() = 0;\n\n  // This function MUST somehow call NotifyDone/NotifyCanceled or some requests\n  // will get leaked. Certain callers use that message to know when they can\n  // delete their URLRequest object, even when doing a cancel. The default\n  // Kill implementation calls NotifyCanceled, so it is recommended that\n  // subclasses call URLRequestJob::Kill() after doing any additional work.\n  //\n  // The job should endeavor to stop working as soon as is convenient, but must\n  // not send and complete notifications from inside this function. Instead,\n  // complete notifications (including \"canceled\") should be sent from a\n  // callback run from the message loop.\n  //\n  // The job is not obliged to immediately stop sending data in response to\n  // this call, nor is it obliged to fail with \"canceled\" unless not all data\n  // was sent as a result. A typical case would be where the job is almost\n  // complete and can succeed before the canceled notification can be\n  // dispatched (from the message loop).\n  //\n  // The job should be prepared to receive multiple calls to kill it, but only\n  // one notification must be issued.\n  virtual void Kill();\n\n  // Called to read post-filtered data from this Job, returning the number of\n  // bytes read, 0 when there is no more data, or net error if there was an\n  // error. This is just the backend for URLRequest::Read, see that function for\n  // more info.\n  int Read(IOBuffer* buf, int buf_size);\n\n  // Stops further caching of this request, if any. For more info, see\n  // URLRequest::StopCaching().\n  virtual void StopCaching();\n\n  virtual bool GetFullRequestHeaders(HttpRequestHeaders* headers) const;\n\n  // Get the number of bytes received from network. The values returned by this\n  // will never decrease over the lifetime of the URLRequestJob.\n  virtual int64_t GetTotalReceivedBytes() const;\n\n  // Get the number of bytes sent over the network. The values returned by this\n  // will never decrease over the lifetime of the URLRequestJob.\n  virtual int64_t GetTotalSentBytes() const;\n\n  // Called to fetch the current load state for the job.\n  virtual LoadState GetLoadState() const;\n\n  // Called to fetch the charset for this request.  Only makes sense for some\n  // types of requests. Returns true on success.  Calling this on a type that\n  // doesn't have a charset will return false.\n  virtual bool GetCharset(std::string* charset);\n\n  // Called to get response info.\n  virtual void GetResponseInfo(HttpResponseInfo* info);\n\n  // This returns the times when events actually occurred, rather than the time\n  // each event blocked the request.  See FixupLoadTimingInfo in url_request.h\n  // for more information on the difference.\n  virtual void GetLoadTimingInfo(LoadTimingInfo* load_timing_info) const;\n\n  // Gets the remote endpoint that the network stack is currently fetching the\n  // URL from. Returns true and fills in |endpoint| if it is available; returns\n  // false and leaves |endpoint| unchanged if it is unavailable.\n  virtual bool GetRemoteEndpoint(IPEndPoint* endpoint) const;\n\n  // Populates the network error details of the most recent origin that the\n  // network stack makes the request to.\n  virtual void PopulateNetErrorDetails(NetErrorDetails* details) const;\n\n  // Called to determine if this response is a redirect.  Only makes sense\n  // for some types of requests.  This method returns true if the response\n  // is a redirect, and fills in the location param with the URL of the\n  // redirect.  The HTTP status code (e.g., 302) is filled into\n  // |*http_status_code| to signify the type of redirect.\n  //\n  // The caller is responsible for following the redirect by setting up an\n  // appropriate replacement Job. Note that the redirected location may be\n  // invalid, the caller should be sure it can handle this.\n  //\n  // The default implementation inspects the response_info_.\n  virtual bool IsRedirectResponse(GURL* location, int* http_status_code);\n\n  // Called to determine if it is okay to copy the reference fragment from the\n  // original URL (if existent) to the redirection target when the redirection\n  // target has no reference fragment.\n  //\n  // The default implementation returns true.\n  virtual bool CopyFragmentOnRedirect(const GURL\u0026 location) const;\n\n  // Called to determine if it is okay to redirect this job to the specified\n  // location.  This may be used to implement protocol-specific restrictions.\n  // If this function returns false, then the URLRequest will fail\n  // reporting ERR_UNSAFE_REDIRECT.\n  virtual bool IsSafeRedirect(const GURL\u0026 location);\n\n  // Called to determine if this response is asking for authentication.  Only\n  // makes sense for some types of requests.  The caller is responsible for\n  // obtaining the credentials passing them to SetAuth.\n  virtual bool NeedsAuth();\n\n  // Fills the authentication info with the server's response.\n  virtual void GetAuthChallengeInfo(\n      scoped_refptr\u003cAuthChallengeInfo\u003e* auth_info);\n\n  // Resend the request with authentication credentials.\n  virtual void SetAuth(const AuthCredentials\u0026 credentials);\n\n  // Display the error page without asking for credentials again.\n  virtual void CancelAuth();\n\n  virtual void ContinueWithCertificate(\n      scoped_refptr\u003cX509Certificate\u003e client_cert,\n      scoped_refptr\u003cSSLPrivateKey\u003e client_private_key);\n\n  // Continue processing the request ignoring the last error.\n  virtual void ContinueDespiteLastError();\n\n  void FollowDeferredRedirect();\n\n  // Returns true if the Job is done producing response data and has called\n  // NotifyDone on the request.\n  bool is_done() const { return done_; }\n\n  // Get/Set expected content size\n  int64_t expected_content_size() const { return expected_content_size_; }\n  void set_expected_content_size(const int64_t\u0026 size) {\n    expected_content_size_ = size;\n  }\n\n  // Whether we have processed the response for that request yet.\n  bool has_response_started() const { return has_handled_response_; }\n\n  // The number of bytes read before passing to the filter. This value reflects\n  // bytes read even when there is no filter.\n  int64_t prefilter_bytes_read() const { return prefilter_bytes_read_; }\n\n  // These methods are not applicable to all connections.\n  virtual bool GetMimeType(std::string* mime_type) const;\n  virtual int GetResponseCode() const;\n\n  // Returns the socket address for the connection.\n  // See url_request.h for details.\n  virtual HostPortPair GetSocketAddress() const;\n\n  // base::PowerObserver methods:\n  // We invoke URLRequestJob::Kill on suspend (crbug.com/4606).\n  void OnSuspend() override;\n\n  // Called after a NetworkDelegate has been informed that the URLRequest\n  // will be destroyed. This is used to track that no pending callbacks\n  // exist at destruction time of the URLRequestJob, unless they have been\n  // canceled by an explicit NetworkDelegate::NotifyURLRequestDestroyed() call.\n  virtual void NotifyURLRequestDestroyed();\n\n  // Populates |out| with the connection attempts made at the socket layer in\n  // the course of executing the URLRequestJob. Should be called after the job\n  // has failed or the response headers have been received.\n  virtual void GetConnectionAttempts(ConnectionAttempts* out) const;\n\n  // Sets a callback that will be invoked each time the request is about to\n  // be actually sent and will receive actual request headers that are about\n  // to hit the wire, including SPDY/QUIC internal headers and any additional\n  // request headers set via BeforeSendHeaders hooks.\n  virtual void SetRequestHeadersCallback(RequestHeadersCallback callback) {}\n\n  // Sets a callback that will be invoked each time the response is received\n  // from the remote party with the actual response headers recieved.\n  virtual void SetResponseHeadersCallback(ResponseHeadersCallback callback) {}\n\n  // Given |policy|, |referrer|, and |destination|, returns the\n  // referrer URL mandated by |request|'s referrer policy.\n  static GURL ComputeReferrerForPolicy(URLRequest::ReferrerPolicy policy,\n                                       const GURL\u0026 original_referrer,\n                                       const GURL\u0026 destination);\n\n protected:\n  // Notifies the job that a certificate is requested.\n  void NotifyCertificateRequested(SSLCertRequestInfo* cert_request_info);\n\n  // Notifies the job about an SSL certificate error.\n  void NotifySSLCertificateError(const SSLInfo\u0026 ssl_info, bool fatal);\n\n  // Delegates to URLRequest::Delegate.\n  bool CanGetCookies(const CookieList\u0026 cookie_list) const;\n\n  // Delegates to URLRequest::Delegate.\n  bool CanSetCookie(const std::string\u0026 cookie_line,\n                    CookieOptions* options) const;\n\n  // Delegates to URLRequest::Delegate.\n  bool CanEnablePrivacyMode() const;\n\n  // Notifies the job that headers have been received.\n  void NotifyHeadersComplete();\n\n  // Notifies the request that a start error has occurred.\n  void NotifyStartError(const URLRequestStatus\u0026 status);\n\n  // Used as an asynchronous callback for Kill to notify the URLRequest\n  // that we were canceled.\n  void NotifyCanceled();\n\n  // Notifies the job the request should be restarted.\n  // Should only be called if the job has not started a response.\n  void NotifyRestartRequired();\n\n  // See corresponding functions in url_request.h.\n  void OnCallToDelegate();\n  void OnCallToDelegateComplete();\n\n  // Called to read raw (pre-filtered) data from this Job. Reads at most\n  // |buf_size| bytes into |buf|.\n  // Possible return values:\n  //   \u003e= 0: Read completed synchronously. Return value is the number of bytes\n  //         read. 0 means eof.\n  //   ERR_IO_PENDING: Read pending asynchronously.\n  //                   When the read completes, |ReadRawDataComplete| should be\n  //                   called.\n  //   Any other negative number: Read failed synchronously. Return value is a\n  //                   network error code.\n  // This method might hold onto a reference to |buf| (by incrementing the\n  // refcount) until the method completes or is cancelled.\n  virtual int ReadRawData(IOBuffer* buf, int buf_size);\n\n  // Called to tell the job that a filter has successfully reached the end of\n  // the stream.\n  virtual void DoneReading();\n\n  // Called to tell the job that the body won't be read because it's a redirect.\n  // This is needed so that redirect headers can be cached even though their\n  // bodies are never read.\n  virtual void DoneReadingRedirectResponse();\n\n  // Called to set up a SourceStream chain for this request.\n  // Subclasses should return the appropriate last SourceStream of the chain,\n  // or nullptr on error.\n  virtual std::unique_ptr\u003cSourceStream\u003e SetUpSourceStream();\n\n  // Provides derived classes with access to the request's network delegate.\n  NetworkDelegate* network_delegate() { return network_delegate_; }\n\n  // The status of the job.\n  const URLRequestStatus GetStatus();\n\n  // Set the proxy server that was used, if any.\n  void SetProxyServer(const ProxyServer\u0026 proxy_server);\n\n  // The number of bytes read after passing through the filter. This value\n  // reflects bytes read even when there is no filter.\n  int64_t postfilter_bytes_read() const { return postfilter_bytes_read_; }\n\n  // Turns an integer result code into an Error and a count of bytes read.\n  // The semantics are:\n  //   |result| \u003e= 0: |*error| == OK, |*count| == |result|\n  //   |result| \u003c 0: |*error| = |result|, |*count| == 0\n  static void ConvertResultToError(int result, Error* error, int* count);\n\n  // Completion callback for raw reads. See |ReadRawData| for details.\n  // |bytes_read| is either \u003e= 0 to indicate a successful read and count of\n  // bytes read, or \u003c 0 to indicate an error.\n  // On return, |this| may be deleted.\n  void ReadRawDataComplete(int bytes_read);\n\n  // The request that initiated this job. This value will never be nullptr.\n  URLRequest* const request_;\n\n private:\n  class URLRequestJobSourceStream;\n\n  // Helper method used to perform tasks after reading from |source_stream_| is\n  // completed. |synchronous| true if the read completed synchronously.\n  // See the documentation for |Read| above for the contract of this method.\n  void SourceStreamReadComplete(bool synchronous, int result);\n\n  // Invokes ReadRawData and records bytes read if the read completes\n  // synchronously.\n  int ReadRawDataHelper(IOBuffer* buf,\n                        int buf_size,\n                        const CompletionCallback\u0026 callback);\n\n  // Returns OK if |new_url| is a valid redirect target and an error code\n  // otherwise.\n  int CanFollowRedirect(const GURL\u0026 new_url);\n\n  // Called in response to a redirect that was not canceled to follow the\n  // redirect. The current job will be replaced with a new job loading the\n  // given redirect destination.\n  void FollowRedirect(const RedirectInfo\u0026 redirect_info);\n\n  // Called after every raw read. If |bytes_read| is \u003e 0, this indicates\n  // a successful read of |bytes_read| unfiltered bytes. If |bytes_read|\n  // is 0, this indicates that there is no additional data to read.\n  // If |bytes_read| is negative, no bytes were read.\n  void GatherRawReadStats(int bytes_read);\n\n  // Updates the profiling info and notifies observers that an additional\n  // |bytes_read| unfiltered bytes have been read for this job.\n  void RecordBytesRead(int bytes_read);\n\n  // OnDone marks that request is done. It is really a glorified\n  // set_status, but also does internal state checking and job tracking. It\n  // should be called once per request, when the job is finished doing all IO.\n  //\n  // If |notify_done| is true, will notify the URLRequest if there was an error\n  // asynchronously.  Otherwise, the caller will need to do this itself,\n  // possibly through a synchronous return value.\n  // TODO(mmenke):  Remove |notify_done|, and make caller handle notification.\n  void OnDone(const URLRequestStatus\u0026 status, bool notify_done);\n\n  // Takes care of the notification initiated by OnDone() to avoid re-entering\n  // the URLRequest::Delegate.\n  void NotifyDone();\n\n  // Subclasses may implement this method to record packet arrival times.\n  // The default implementation does nothing.  Only invoked when bytes have been\n  // read since the last invocation.\n  virtual void UpdatePacketReadTimes();\n\n  // Computes a new RedirectInfo based on receiving a redirect response of\n  // |location| and |http_status_code|.\n  RedirectInfo ComputeRedirectInfo(const GURL\u0026 location, int http_status_code);\n\n  // Notify the network delegate that more bytes have been received or sent over\n  // the network, if bytes have been received or sent since the previous\n  // notification.\n  void MaybeNotifyNetworkBytes();\n\n  // Indicates that the job is done producing data, either it has completed\n  // all the data or an error has been encountered. Set exclusively by\n  // NotifyDone so that it is kept in sync with the request.\n  bool done_;\n\n  // Number of raw network bytes read from job subclass.\n  int64_t prefilter_bytes_read_;\n\n  // Number of bytes after applying |source_stream_| filters.\n  int64_t postfilter_bytes_read_;\n\n  // The first SourceStream of the SourceStream chain used.\n  std::unique_ptr\u003cSourceStream\u003e source_stream_;\n\n  // Keep a reference to the buffer passed in via URLRequestJob::Read() so it\n  // doesn't get destroyed when the read has not completed.\n  scoped_refptr\u003cIOBuffer\u003e pending_read_buffer_;\n\n  // We keep a pointer to the read buffer while asynchronous reads are\n  // in progress, so we are able to pass those bytes to job observers.\n  scoped_refptr\u003cIOBuffer\u003e raw_read_buffer_;\n\n  // Used by HandleResponseIfNecessary to track whether we've sent the\n  // OnResponseStarted callback and potentially redirect callbacks as well.\n  bool has_handled_response_;\n\n  // Expected content size\n  int64_t expected_content_size_;\n\n  // Set when a redirect is deferred. Redirects are deferred after validity\n  // checks are performed, so this field must not be modified.\n  RedirectInfo deferred_redirect_info_;\n\n  // The network delegate to use with this request, if any.\n  NetworkDelegate* network_delegate_;\n\n  // The value from GetTotalReceivedBytes() the last time\n  // MaybeNotifyNetworkBytes() was called. Used to calculate how bytes have been\n  // newly received since the last notification.\n  int64_t last_notified_total_received_bytes_;\n\n  // The value from GetTotalSentBytes() the last time MaybeNotifyNetworkBytes()\n  // was called. Used to calculate how bytes have been newly sent since the last\n  // notification.\n  int64_t last_notified_total_sent_bytes_;\n\n  // Non-null if ReadRawData() returned ERR_IO_PENDING, and the read has not\n  // completed.\n  CompletionCallback read_raw_callback_;\n\n  base::WeakPtrFactory\u003cURLRequestJob\u003e weak_factory_;\n\n  DISALLOW_COPY_AND_ASSIGN(URLRequestJob);\n};\n\n}  // namespace net\n\n#endif  // NET_URL_REQUEST_URL_REQUEST_JOB_H_\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"40d02904f5ee153daa2d5cd666ccfdf2756687ce","path":"net/url_request/url_request_job.h"}}}],"elapsed_ms":25}