{"file_info_response":[{"return_code":1,"file_info":{"name":"src/net/http/http_network_transaction.h","lines":"427","size":"16377","language":"c++","type":1,"md5":"2e1aa1ff60b0af2727801f38954b7c77","changelist_num":"40d02904f5ee153daa2d5cd666ccfdf2756687ce","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef NET_HTTP_HTTP_NETWORK_TRANSACTION_H_\n#define NET_HTTP_HTTP_NETWORK_TRANSACTION_H_\n\n#include \u003cstdint.h\u003e\n\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n\n#include \"base/gtest_prod_util.h\"\n#include \"base/macros.h\"\n#include \"base/memory/ref_counted.h\"\n#include \"base/time/time.h\"\n#include \"crypto/ec_private_key.h\"\n#include \"net/base/net_error_details.h\"\n#include \"net/base/net_export.h\"\n#include \"net/base/network_throttle_manager.h\"\n#include \"net/base/request_priority.h\"\n#include \"net/http/http_auth.h\"\n#include \"net/http/http_request_headers.h\"\n#include \"net/http/http_response_info.h\"\n#include \"net/http/http_stream_factory.h\"\n#include \"net/http/http_transaction.h\"\n#include \"net/log/net_log_with_source.h\"\n#include \"net/proxy/proxy_service.h\"\n#include \"net/socket/connection_attempts.h\"\n#include \"net/ssl/channel_id_service.h\"\n#include \"net/ssl/ssl_config_service.h\"\n#include \"net/websockets/websocket_handshake_stream_base.h\"\n\nnamespace crypto {\nclass ECPrivateKey;\n}\n\nnamespace net {\n\nclass BidirectionalStreamImpl;\nclass HttpAuthController;\nclass HttpNetworkSession;\nclass HttpStream;\nclass HttpStreamRequest;\nclass IOBuffer;\nclass ProxyInfo;\nclass SSLPrivateKey;\nstruct HttpRequestInfo;\n\nclass NET_EXPORT_PRIVATE HttpNetworkTransaction\n    : public HttpTransaction,\n      public HttpStreamRequest::Delegate,\n      public NetworkThrottleManager::ThrottleDelegate {\n public:\n  HttpNetworkTransaction(RequestPriority priority,\n                         HttpNetworkSession* session);\n\n  ~HttpNetworkTransaction() override;\n\n  // HttpTransaction methods:\n  int Start(const HttpRequestInfo* request_info,\n            const CompletionCallback\u0026 callback,\n            const NetLogWithSource\u0026 net_log) override;\n  int RestartIgnoringLastError(const CompletionCallback\u0026 callback) override;\n  int RestartWithCertificate(scoped_refptr\u003cX509Certificate\u003e client_cert,\n                             scoped_refptr\u003cSSLPrivateKey\u003e client_private_key,\n                             const CompletionCallback\u0026 callback) override;\n  int RestartWithAuth(const AuthCredentials\u0026 credentials,\n                      const CompletionCallback\u0026 callback) override;\n  bool IsReadyToRestartForAuth() override;\n\n  int Read(IOBuffer* buf,\n           int buf_len,\n           const CompletionCallback\u0026 callback) override;\n  void StopCaching() override;\n  bool GetFullRequestHeaders(HttpRequestHeaders* headers) const override;\n  int64_t GetTotalReceivedBytes() const override;\n  int64_t GetTotalSentBytes() const override;\n  void DoneReading() override;\n  const HttpResponseInfo* GetResponseInfo() const override;\n  LoadState GetLoadState() const override;\n  void SetQuicServerInfo(QuicServerInfo* quic_server_info) override;\n  bool GetLoadTimingInfo(LoadTimingInfo* load_timing_info) const override;\n  bool GetRemoteEndpoint(IPEndPoint* endpoint) const override;\n  void PopulateNetErrorDetails(NetErrorDetails* details) const override;\n  void SetPriority(RequestPriority priority) override;\n  void SetWebSocketHandshakeStreamCreateHelper(\n      WebSocketHandshakeStreamBase::CreateHelper* create_helper) override;\n  void SetBeforeNetworkStartCallback(\n      const BeforeNetworkStartCallback\u0026 callback) override;\n  void SetBeforeHeadersSentCallback(\n      const BeforeHeadersSentCallback\u0026 callback) override;\n  void SetRequestHeadersCallback(RequestHeadersCallback callback) override;\n  void SetResponseHeadersCallback(ResponseHeadersCallback callback) override;\n\n  int ResumeNetworkStart() override;\n\n  // HttpStreamRequest::Delegate methods:\n  void OnStreamReady(const SSLConfig\u0026 used_ssl_config,\n                     const ProxyInfo\u0026 used_proxy_info,\n                     std::unique_ptr\u003cHttpStream\u003e stream) override;\n  void OnBidirectionalStreamImplReady(\n      const SSLConfig\u0026 used_ssl_config,\n      const ProxyInfo\u0026 used_proxy_info,\n      std::unique_ptr\u003cBidirectionalStreamImpl\u003e stream) override;\n  void OnWebSocketHandshakeStreamReady(\n      const SSLConfig\u0026 used_ssl_config,\n      const ProxyInfo\u0026 used_proxy_info,\n      std::unique_ptr\u003cWebSocketHandshakeStreamBase\u003e stream) override;\n  void OnStreamFailed(int status,\n                      const NetErrorDetails\u0026 net_error_details,\n                      const SSLConfig\u0026 used_ssl_config) override;\n  void OnCertificateError(int status,\n                          const SSLConfig\u0026 used_ssl_config,\n                          const SSLInfo\u0026 ssl_info) override;\n  void OnNeedsProxyAuth(const HttpResponseInfo\u0026 response_info,\n                        const SSLConfig\u0026 used_ssl_config,\n                        const ProxyInfo\u0026 used_proxy_info,\n                        HttpAuthController* auth_controller) override;\n  void OnNeedsClientAuth(const SSLConfig\u0026 used_ssl_config,\n                         SSLCertRequestInfo* cert_info) override;\n  void OnHttpsProxyTunnelResponse(const HttpResponseInfo\u0026 response_info,\n                                  const SSLConfig\u0026 used_ssl_config,\n                                  const ProxyInfo\u0026 used_proxy_info,\n                                  std::unique_ptr\u003cHttpStream\u003e stream) override;\n\n  void OnQuicBroken() override;\n  void GetConnectionAttempts(ConnectionAttempts* out) const override;\n\n  // NetworkThrottleManager::Delegate methods:\n  void OnThrottleUnblocked(NetworkThrottleManager::Throttle* throttle) override;\n\n private:\n  FRIEND_TEST_ALL_PREFIXES(HttpNetworkTransactionTest, ResetStateForRestart);\n  FRIEND_TEST_ALL_PREFIXES(SpdyNetworkTransactionTest, WindowUpdateReceived);\n  FRIEND_TEST_ALL_PREFIXES(SpdyNetworkTransactionTest, WindowUpdateSent);\n  FRIEND_TEST_ALL_PREFIXES(SpdyNetworkTransactionTest, WindowUpdateOverflow);\n  FRIEND_TEST_ALL_PREFIXES(SpdyNetworkTransactionTest, FlowControlStallResume);\n  FRIEND_TEST_ALL_PREFIXES(SpdyNetworkTransactionTest,\n                           FlowControlStallResumeAfterSettings);\n  FRIEND_TEST_ALL_PREFIXES(SpdyNetworkTransactionTest,\n                           FlowControlNegativeSendWindowSize);\n\n  enum State {\n    STATE_THROTTLE,\n    STATE_THROTTLE_COMPLETE,\n    STATE_NOTIFY_BEFORE_CREATE_STREAM,\n    STATE_CREATE_STREAM,\n    STATE_CREATE_STREAM_COMPLETE,\n    STATE_INIT_STREAM,\n    STATE_INIT_STREAM_COMPLETE,\n    STATE_GENERATE_PROXY_AUTH_TOKEN,\n    STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE,\n    STATE_GENERATE_SERVER_AUTH_TOKEN,\n    STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE,\n    STATE_GET_PROVIDED_TOKEN_BINDING_KEY,\n    STATE_GET_PROVIDED_TOKEN_BINDING_KEY_COMPLETE,\n    STATE_GET_REFERRED_TOKEN_BINDING_KEY,\n    STATE_GET_REFERRED_TOKEN_BINDING_KEY_COMPLETE,\n    STATE_INIT_REQUEST_BODY,\n    STATE_INIT_REQUEST_BODY_COMPLETE,\n    STATE_BUILD_REQUEST,\n    STATE_BUILD_REQUEST_COMPLETE,\n    STATE_SEND_REQUEST,\n    STATE_SEND_REQUEST_COMPLETE,\n    STATE_READ_HEADERS,\n    STATE_READ_HEADERS_COMPLETE,\n    STATE_READ_BODY,\n    STATE_READ_BODY_COMPLETE,\n    STATE_DRAIN_BODY_FOR_AUTH_RESTART,\n    STATE_DRAIN_BODY_FOR_AUTH_RESTART_COMPLETE,\n    STATE_NONE\n  };\n\n  bool IsSecureRequest() const;\n  bool IsTokenBindingEnabled() const;\n  void RecordTokenBindingSupport() const;\n\n  // Returns true if the request is using an HTTP(S) proxy without being\n  // tunneled via the CONNECT method.\n  bool UsingHttpProxyWithoutTunnel() const;\n\n  void DoCallback(int result);\n  void OnIOComplete(int result);\n\n  // Runs the state transition loop.\n  int DoLoop(int result);\n\n  // Each of these methods corresponds to a State value.  Those with an input\n  // argument receive the result from the previous state.  If a method returns\n  // ERR_IO_PENDING, then the result from OnIOComplete will be passed to the\n  // next state method as the result arg.\n  int DoThrottle();\n  int DoThrottleComplete();\n  int DoNotifyBeforeCreateStream();\n  int DoCreateStream();\n  int DoCreateStreamComplete(int result);\n  int DoInitStream();\n  int DoInitStreamComplete(int result);\n  int DoGenerateProxyAuthToken();\n  int DoGenerateProxyAuthTokenComplete(int result);\n  int DoGenerateServerAuthToken();\n  int DoGenerateServerAuthTokenComplete(int result);\n  int DoGetProvidedTokenBindingKey();\n  int DoGetProvidedTokenBindingKeyComplete(int result);\n  int DoGetReferredTokenBindingKey();\n  int DoGetReferredTokenBindingKeyComplete(int result);\n  int DoInitRequestBody();\n  int DoInitRequestBodyComplete(int result);\n  int DoBuildRequest();\n  int DoBuildRequestComplete(int result);\n  int DoSendRequest();\n  int DoSendRequestComplete(int result);\n  int DoReadHeaders();\n  int DoReadHeadersComplete(int result);\n  int DoReadBody();\n  int DoReadBodyComplete(int result);\n  int DoDrainBodyForAuthRestart();\n  int DoDrainBodyForAuthRestartComplete(int result);\n\n  int BuildRequestHeaders(bool using_http_proxy_without_tunnel);\n  int BuildTokenBindingHeader(std::string* out);\n\n  // Writes a log message to help debugging in the field when we block a proxy\n  // response to a CONNECT request.\n  void LogBlockedTunnelResponse(int response_code) const;\n\n  // Called to handle a client certificate request.\n  int HandleCertificateRequest(int error);\n\n  // Called wherever ERR_HTTP_1_1_REQUIRED or\n  // ERR_PROXY_HTTP_1_1_REQUIRED has to be handled.\n  int HandleHttp11Required(int error);\n\n  // Called to possibly handle a client authentication error.\n  void HandleClientAuthError(int error);\n\n  // Called to possibly recover from an SSL handshake error.  Sets next_state_\n  // and returns OK if recovering from the error.  Otherwise, the same error\n  // code is returned.\n  int HandleSSLHandshakeError(int error);\n\n  // Called to possibly recover from the given error.  Sets next_state_ and\n  // returns OK if recovering from the error.  Otherwise, the same error code\n  // is returned.\n  int HandleIOError(int error);\n\n  // Gets the response headers from the HttpStream.\n  HttpResponseHeaders* GetResponseHeaders() const;\n\n  // Called when the socket is unexpectedly closed.  Returns true if the request\n  // should be resent in case of a socket reuse/close race.\n  bool ShouldResendRequest() const;\n\n  // Returns true if there have already been |kMaxRetryAttempts| retries for\n  // HTTP2 or QUIC network errors, and no further retries should be attempted.\n  bool HasExceededMaxRetries() const;\n\n  // Resets the connection and the request headers for resend.  Called when\n  // ShouldResendRequest() is true.\n  void ResetConnectionAndRequestForResend();\n\n  // Sets up the state machine to restart the transaction with auth.\n  void PrepareForAuthRestart(HttpAuth::Target target);\n\n  // Called when we don't need to drain the response body or have drained it.\n  // Resets |connection_| unless |keep_alive| is true, then calls\n  // ResetStateForRestart.  Sets |next_state_| appropriately.\n  void DidDrainBodyForAuthRestart(bool keep_alive);\n\n  // Resets the members of the transaction so it can be restarted.\n  void ResetStateForRestart();\n\n  // Resets the members of the transaction, except |stream_|, which needs\n  // to be maintained for multi-round auth.\n  void ResetStateForAuthRestart();\n\n  // Caches network error details from the stream if available\n  // and resets the stream.\n  void CacheNetErrorDetailsAndResetStream();\n\n  // Returns true if we should try to add a Proxy-Authorization header\n  bool ShouldApplyProxyAuth() const;\n\n  // Returns true if we should try to add an Authorization header.\n  bool ShouldApplyServerAuth() const;\n\n  // Handles HTTP status code 401 or 407.\n  // HandleAuthChallenge() returns a network error code, or OK on success.\n  // May update |pending_auth_target_| or |response_.auth_challenge|.\n  int HandleAuthChallenge();\n\n  // Returns true if we have auth credentials for the given target.\n  bool HaveAuth(HttpAuth::Target target) const;\n\n  // Get the {scheme, host, path, port} for the authentication target\n  GURL AuthURL(HttpAuth::Target target) const;\n\n  // Returns true if this transaction is for a WebSocket handshake\n  bool ForWebSocketHandshake() const;\n\n  void SetStream(HttpStream* stream);\n\n  void CopyConnectionAttemptsFromStreamRequest();\n\n  // Returns true if response \"Content-Encoding\" headers respect\n  // \"Accept-Encoding\".\n  bool ContentEncodingsValid() const;\n\n  scoped_refptr\u003cHttpAuthController\u003e\n      auth_controllers_[HttpAuth::AUTH_NUM_TARGETS];\n\n  // Whether this transaction is waiting for proxy auth, server auth, or is\n  // not waiting for any auth at all. |pending_auth_target_| is read and\n  // cleared by RestartWithAuth().\n  HttpAuth::Target pending_auth_target_;\n\n  CompletionCallback io_callback_;\n  CompletionCallback callback_;\n\n  HttpNetworkSession* session_;\n\n  NetLogWithSource net_log_;\n\n  // Reset to null at the start of the Read state machine.\n  const HttpRequestInfo* request_;\n\n  // The requested URL.\n  GURL url_;\n  RequestPriority priority_;\n  HttpResponseInfo response_;\n\n  // |proxy_info_| is the ProxyInfo used by the HttpStreamRequest.\n  ProxyInfo proxy_info_;\n\n  std::unique_ptr\u003cHttpStreamRequest\u003e stream_request_;\n  std::unique_ptr\u003cHttpStream\u003e stream_;\n\n  // True if we've validated the headers that the stream parser has returned.\n  bool headers_valid_;\n\n  SSLConfig server_ssl_config_;\n  SSLConfig proxy_ssl_config_;\n\n  // Keys to use for signing message in Token Binding header.\n  std::unique_ptr\u003ccrypto::ECPrivateKey\u003e provided_token_binding_key_;\n  std::unique_ptr\u003ccrypto::ECPrivateKey\u003e referred_token_binding_key_;\n  // Object to manage lookup of |provided_token_binding_key_| and\n  // |referred_token_binding_key_|.\n  ChannelIDService::Request token_binding_request_;\n\n  HttpRequestHeaders request_headers_;\n\n  // The size in bytes of the buffer we use to drain the response body that\n  // we want to throw away.  The response body is typically a small error\n  // page just a few hundred bytes long.\n  static const int kDrainBodyBufferSize = 1024;\n\n  // User buffer and length passed to the Read method.\n  scoped_refptr\u003cIOBuffer\u003e read_buf_;\n  int read_buf_len_;\n\n  // Total number of bytes received on all destroyed HttpStreams for this\n  // transaction.\n  int64_t total_received_bytes_;\n\n  // Total number of bytes sent on all destroyed HttpStreams for this\n  // transaction.\n  int64_t total_sent_bytes_;\n\n  // When the transaction started / finished sending the request, including\n  // the body, if present.\n  base::TimeTicks send_start_time_;\n  base::TimeTicks send_end_time_;\n\n  // The next state in the state machine.\n  State next_state_;\n\n  // True when the tunnel is in the process of being established - we can't\n  // read from the socket until the tunnel is done.\n  bool establishing_tunnel_;\n\n  // Enable pooling to a SpdySession with matching IP and certificate\n  // even if the SpdySessionKey is different.\n  bool enable_ip_based_pooling_;\n\n  // Enable using alternative services for the request.\n  bool enable_alternative_services_;\n\n  // When a request is retried because of errors with the alternative service,\n  // this will store the alternative service used.\n  AlternativeService retried_alternative_service_;\n\n  // The helper object to use to create WebSocketHandshakeStreamBase\n  // objects. Only relevant when establishing a WebSocket connection.\n  WebSocketHandshakeStreamBase::CreateHelper*\n      websocket_handshake_stream_base_create_helper_;\n\n  BeforeNetworkStartCallback before_network_start_callback_;\n  BeforeHeadersSentCallback before_headers_sent_callback_;\n  RequestHeadersCallback request_headers_callback_;\n  ResponseHeadersCallback response_headers_callback_;\n\n  ConnectionAttempts connection_attempts_;\n  IPEndPoint remote_endpoint_;\n  // Network error details for this transaction.\n  NetErrorDetails net_error_details_;\n\n  // Communicate lifetime of transaction to the throttler, and\n  // throttled state to the transaction.\n  std::unique_ptr\u003cNetworkThrottleManager::Throttle\u003e throttle_;\n\n  // Number of retries made for network errors like ERR_SPDY_PING_FAILED,\n  // ERR_SPDY_SERVER_REFUSED_STREAM, ERR_QUIC_HANDSHAKE_FAILED and\n  // ERR_QUIC_PROTOCOL_ERROR. Currently we stop after 3 tries\n  // (including the initial request) and fail the request.\n  // This count excludes retries on reused sockets since a well\n  // behaved server may time those out and thus the number\n  // of times we can retry a request on reused sockets is limited.\n  size_t retry_attempts_;\n\n  DISALLOW_COPY_AND_ASSIGN(HttpNetworkTransaction);\n};\n\n}  // namespace net\n\n#endif  // NET_HTTP_HTTP_NETWORK_TRANSACTION_H_\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"40d02904f5ee153daa2d5cd666ccfdf2756687ce","path":"net/http/http_network_transaction.h"}}}],"elapsed_ms":65}