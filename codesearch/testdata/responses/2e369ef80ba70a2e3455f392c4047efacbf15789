{"file_info_response":[{"return_code":1,"file_info":{"name":"src/net/base/io_buffer.h","lines":"258","size":"8790","language":"c++","type":1,"md5":"05720c63754a10c420f9ce73406be591","changelist_num":"40d02904f5ee153daa2d5cd666ccfdf2756687ce","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef NET_BASE_IO_BUFFER_H_\n#define NET_BASE_IO_BUFFER_H_\n\n#include \u003cstddef.h\u003e\n\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n\n#include \"base/memory/free_deleter.h\"\n#include \"base/memory/ref_counted.h\"\n#include \"base/pickle.h\"\n#include \"net/base/net_export.h\"\n\nnamespace net {\n\n// IOBuffers are reference counted data buffers used for easier asynchronous\n// IO handling.\n//\n// They are often used as the destination buffers for Read() operations, or as\n// the source buffers for Write() operations.\n//\n// IMPORTANT: Never re-use an IOBuffer after cancelling the IO operation that\n//            was using it, since this may lead to memory corruption!\n//\n// -----------------------\n// Ownership of IOBuffers:\n// -----------------------\n//\n// Although IOBuffers are RefCountedThreadSafe, they are not intended to be\n// used as a shared buffer, nor should they be used simultaneously across\n// threads. The fact that they are reference counted is an implementation\n// detail for allowing them to outlive cancellation of asynchronous\n// operations.\n//\n// Instead, think of the underlying |char*| buffer contained by the IOBuffer\n// as having exactly one owner at a time.\n//\n// Whenever you call an asynchronous operation that takes an IOBuffer,\n// ownership is implicitly transferred to the called function, until the\n// operation has completed (at which point it transfers back to the caller).\n//\n//     ==\u003e The IOBuffer's data should NOT be manipulated, destroyed, or read\n//         until the operation has completed.\n//\n//     ==\u003e Cancellation does NOT count as completion. If an operation using\n//         an IOBuffer is cancelled, the caller should release their\n//         reference to this IOBuffer at the time of cancellation since\n//         they can no longer use it.\n//\n// For instance, if you were to call a Read() operation on some class which\n// takes an IOBuffer, and then delete that class (which generally will\n// trigger cancellation), the IOBuffer which had been passed to Read() should\n// never be re-used.\n//\n// This usage contract is assumed by any API which takes an IOBuffer, even\n// though it may not be explicitly mentioned in the function's comments.\n//\n// -----------------------\n// Motivation\n// -----------------------\n//\n// The motivation for transferring ownership during cancellation is\n// to make it easier to work with un-cancellable operations.\n//\n// For instance, let's say under the hood your API called out to the\n// operating system's synchronous ReadFile() function on a worker thread.\n// When cancelling through our asynchronous interface, we have no way of\n// actually aborting the in progress ReadFile(). We must let it keep running,\n// and hence the buffer it was reading into must remain alive. Using\n// reference counting we can add a reference to the IOBuffer and make sure\n// it is not destroyed until after the synchronous operation has completed.\nclass NET_EXPORT IOBuffer : public base::RefCountedThreadSafe\u003cIOBuffer\u003e {\n public:\n  IOBuffer();\n\n  // TODO(eroman): Deprecated. Use the size_t flavor instead. crbug.com/488553\n  explicit IOBuffer(int buffer_size);\n  explicit IOBuffer(size_t buffer_size);\n\n  char* data() const { return data_; }\n\n protected:\n  friend class base::RefCountedThreadSafe\u003cIOBuffer\u003e;\n\n  // Only allow derived classes to specify data_.\n  // In all other cases, we own data_, and must delete it at destruction time.\n  explicit IOBuffer(char* data);\n\n  virtual ~IOBuffer();\n\n  char* data_;\n};\n\n// This version stores the size of the buffer so that the creator of the object\n// doesn't have to keep track of that value.\n// NOTE: This doesn't mean that we want to stop sending the size as an explicit\n// argument to IO functions. Please keep using IOBuffer* for API declarations.\nclass NET_EXPORT IOBufferWithSize : public IOBuffer {\n public:\n  // TODO(eroman): Deprecated. Use the size_t flavor instead. crbug.com/488553\n  explicit IOBufferWithSize(int size);\n  explicit IOBufferWithSize(size_t size);\n\n  int size() const { return size_; }\n\n protected:\n  // TODO(eroman): Deprecated. Use the size_t flavor instead. crbug.com/488553\n  IOBufferWithSize(char* data, int size);\n\n  // Purpose of this constructor is to give a subclass access to the base class\n  // constructor IOBuffer(char*) thus allowing subclass to use underlying\n  // memory it does not own.\n  IOBufferWithSize(char* data, size_t size);\n  ~IOBufferWithSize() override;\n\n  int size_;\n};\n\n// This is a read only IOBuffer.  The data is stored in a string and\n// the IOBuffer interface does not provide a proper way to modify it.\nclass NET_EXPORT StringIOBuffer : public IOBuffer {\n public:\n  explicit StringIOBuffer(const std::string\u0026 s);\n  explicit StringIOBuffer(std::unique_ptr\u003cstd::string\u003e s);\n\n  int size() const { return static_cast\u003cint\u003e(string_data_.size()); }\n\n private:\n  ~StringIOBuffer() override;\n\n  std::string string_data_;\n};\n\n// This version wraps an existing IOBuffer and provides convenient functions\n// to progressively read all the data.\n//\n// DrainableIOBuffer is useful when you have an IOBuffer that contains data\n// to be written progressively, and Write() function takes an IOBuffer rather\n// than char*. DrainableIOBuffer can be used as follows:\n//\n// // payload is the IOBuffer containing the data to be written.\n// buf = new DrainableIOBuffer(payload, payload_size);\n//\n// while (buf-\u003eBytesRemaining() \u003e 0) {\n//   // Write() takes an IOBuffer. If it takes char*, we could\n//   // simply use the regular IOBuffer like payload-\u003edata() + offset.\n//   int bytes_written = Write(buf, buf-\u003eBytesRemaining());\n//   buf-\u003eDidConsume(bytes_written);\n// }\n//\nclass NET_EXPORT DrainableIOBuffer : public IOBuffer {\n public:\n  // TODO(eroman): Deprecated. Use the size_t flavor instead. crbug.com/488553\n  DrainableIOBuffer(IOBuffer* base, int size);\n  DrainableIOBuffer(IOBuffer* base, size_t size);\n\n  // DidConsume() changes the |data_| pointer so that |data_| always points\n  // to the first unconsumed byte.\n  void DidConsume(int bytes);\n\n  // Returns the number of unconsumed bytes.\n  int BytesRemaining() const;\n\n  // Returns the number of consumed bytes.\n  int BytesConsumed() const;\n\n  // Seeks to an arbitrary point in the buffer. The notion of bytes consumed\n  // and remaining are updated appropriately.\n  void SetOffset(int bytes);\n\n  int size() const { return size_; }\n\n private:\n  ~DrainableIOBuffer() override;\n\n  scoped_refptr\u003cIOBuffer\u003e base_;\n  int size_;\n  int used_;\n};\n\n// This version provides a resizable buffer and a changeable offset.\n//\n// GrowableIOBuffer is useful when you read data progressively without\n// knowing the total size in advance. GrowableIOBuffer can be used as\n// follows:\n//\n// buf = new GrowableIOBuffer;\n// buf-\u003eSetCapacity(1024);  // Initial capacity.\n//\n// while (!some_stream-\u003eIsEOF()) {\n//   // Double the capacity if the remaining capacity is empty.\n//   if (buf-\u003eRemainingCapacity() == 0)\n//     buf-\u003eSetCapacity(buf-\u003ecapacity() * 2);\n//   int bytes_read = some_stream-\u003eRead(buf, buf-\u003eRemainingCapacity());\n//   buf-\u003eset_offset(buf-\u003eoffset() + bytes_read);\n// }\n//\nclass NET_EXPORT GrowableIOBuffer : public IOBuffer {\n public:\n  GrowableIOBuffer();\n\n  // realloc memory to the specified capacity.\n  void SetCapacity(int capacity);\n  int capacity() { return capacity_; }\n\n  // |offset| moves the |data_| pointer, allowing \"seeking\" in the data.\n  void set_offset(int offset);\n  int offset() { return offset_; }\n\n  int RemainingCapacity();\n  char* StartOfBuffer();\n\n private:\n  ~GrowableIOBuffer() override;\n\n  std::unique_ptr\u003cchar, base::FreeDeleter\u003e real_data_;\n  int capacity_;\n  int offset_;\n};\n\n// This versions allows a pickle to be used as the storage for a write-style\n// operation, avoiding an extra data copy.\nclass NET_EXPORT PickledIOBuffer : public IOBuffer {\n public:\n  PickledIOBuffer();\n\n  base::Pickle* pickle() { return \u0026pickle_; }\n\n  // Signals that we are done writing to the pickle and we can use it for a\n  // write-style IO operation.\n  void Done();\n\n private:\n  ~PickledIOBuffer() override;\n\n  base::Pickle pickle_;\n};\n\n// This class allows the creation of a temporary IOBuffer that doesn't really\n// own the underlying buffer. Please use this class only as a last resort.\n// A good example is the buffer for a synchronous operation, where we can be\n// sure that nobody is keeping an extra reference to this object so the lifetime\n// of the buffer can be completely managed by its intended owner.\nclass NET_EXPORT WrappedIOBuffer : public IOBuffer {\n public:\n  explicit WrappedIOBuffer(const char* data);\n\n protected:\n  ~WrappedIOBuffer() override;\n};\n\n}  // namespace net\n\n#endif  // NET_BASE_IO_BUFFER_H_\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"40d02904f5ee153daa2d5cd666ccfdf2756687ce","path":"net/base/io_buffer.h"}}}],"elapsed_ms":19}